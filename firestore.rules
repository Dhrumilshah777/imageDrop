/**
 * @file Firestore Security Rules for ImageDrop
 *
 * @core_philosophy This ruleset enforces a strict user-ownership model for user profiles and associated images in their private collection.
 *   Images are also stored in a public collection for general browsing, but ownership is still enforced for modifications.
 *   This design prioritizes data privacy and prevents unauthorized access while enabling a shared gallery experience.
 *
 * @data_structure
 *   - /users/{userId}: Stores user profile information, where {userId} is the Firebase Authentication UID.
 *   - /users/{userId}/images/{imageId}: Stores images uploaded by a specific user.
 *   - /images/{imageId}: A top-level collection for all images, enabling public browsing.
 *
 * @key_security_decisions
 *   - User listing is disallowed to prevent enumeration.
 *   - The /images collection allows public reads but restricts writes to the image owner. This pattern relies on the `userId` field within each image document.
 *   - Data consistency is enforced between the `userId` in the path `/users/{userId}` and the `id` field within the `/users/{userId}` document itself.
 *
 * @denormalization_for_authorization
 *   - Images in the `/images` collection must have a `userId` field that matches the user who created them. This is essential for enforcing ownership in the public collection.
 *
 * @structural_segregation
 *   - Uses separate collections for private user images (`/users/{userId}/images/{imageId}`) and public images (`/images/{imageId}`), which simplifies access control and improves query performance.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secures the user profile document. Only the authenticated user can read and write their own profile.
     * @path /users/{userId}
     * @allow (create) User with UID "user_abc" can create their profile document.
     *   request.auth.uid == "user_abc"
     *   request.resource.data.id == "user_abc"
     * @allow (get) User with UID "user_abc" can read their own profile document.
     *   request.auth.uid == "user_abc"
     * @allow (update) User with UID "user_abc" can update their profile document.
     *   request.auth.uid == "user_abc"
     *   resource.data.id == "user_abc"
     * @allow (delete) User with UID "user_abc" can delete their own profile document.
     *   request.auth.uid == "user_abc"
     *   resource.data.id == "user_abc"
     * @deny (create) User with UID "user_abc" cannot create a profile for "user_xyz".
     *   request.auth.uid == "user_abc"
     *   request.resource.data.id == "user_xyz"
     * @deny (get) User with UID "user_abc" cannot read the profile of "user_xyz".
     *   request.auth.uid == "user_abc"
     * @deny (update) User with UID "user_abc" cannot update the profile of "user_xyz".
     *   request.auth.uid == "user_abc"
     *   resource.data.id == "user_xyz"
     * @deny (delete) User with UID "user_abc" cannot delete the profile of "user_xyz".
     *   request.auth.uid == "user_abc"
     *   resource.data.id == "user_xyz"
     * @principle Enforces document ownership for all operations. Validates data consistency.
     */
    match /users/{userId} {
      // Verified user can only access their own user document
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isNewOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secures images stored under a specific user's profile. Only the authenticated user can manage their own images.
     * @path /users/{userId}/images/{imageId}
     * @allow (create) User with UID "user_abc" can create an image in their collection.
     *   request.auth.uid == "user_abc"
     *   request.resource.data.userId == "user_abc"
     * @allow (get) User with UID "user_abc" can read their own image.
     *   request.auth.uid == "user_abc"
     * @allow (list) User with UID "user_abc" can list images in their own collection.
     *   request.auth.uid == "user_abc"
     * @allow (update) User with UID "user_abc" can update their own image.
     *   request.auth.uid == "user_abc"
     *   resource.data.userId == "user_abc"
     * @allow (delete) User with UID "user_abc" can delete their own image.
     *   request.auth.uid == "user_abc"
     *   resource.data.userId == "user_abc"
     * @deny (create) User with UID "user_abc" cannot create an image for "user_xyz".
     *   request.auth.uid == "user_abc"
     *   request.resource.data.userId == "user_xyz"
     * @deny (get) User with UID "user_abc" cannot read an image owned by "user_xyz".
     *   request.auth.uid == "user_abc"
     * @deny (list) User with UID "user_abc" cannot list images owned by "user_xyz".
     *   request.auth.uid == "user_abc"
     * @deny (update) User with UID "user_abc" cannot update an image owned by "user_xyz".
     *   request.auth.uid == "user_abc"
     *   resource.data.userId == "user_xyz"
     * @deny (delete) User with UID "user_abc" cannot delete an image owned by "user_xyz".
     *   request.auth.uid == "user_abc"
     *   resource.data.userId == "user_xyz"
     * @principle Enforces strict user-ownership for images in the private collection.
     */
    match /users/{userId}/images/{imageId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && resource.data.userId == userId;
      allow delete: if isExistingOwner(userId) && resource.data.userId == userId;
    }

    /**
     * @description Grants public read access to all images in the root-level 'images' collection, but restricts write access to the owner.
     * @path /images/{imageId}
     * @allow (get) Any user can read any image in the collection.
     *   request.auth != null
     * @allow (list) Any user can list images in the collection.
     *   request.auth != null
     * @allow (create) User with UID "user_abc" can create an image with their ID as the author.
     *   request.auth.uid == "user_abc"
     *   request.resource.data.userId == "user_abc"
     * @allow (update) User with UID "user_abc" can update their own image in the public collection.
     *   request.auth.uid == "user_abc"
     *   resource.data.userId == "user_abc"
     * @allow (delete) User with UID "user_abc" can delete their own image from the public collection.
     *   request.auth.uid == "user_abc"
     *   resource.data.userId == "user_abc"
     * @deny (create) User with UID "user_abc" cannot create an image for "user_xyz".
     *   request.auth.uid == "user_abc"
     *   request.resource.data.userId == "user_xyz"
     * @deny (update) User with UID "user_abc" cannot update an image owned by "user_xyz".
     *   request.auth.uid == "user_abc"
     *   resource.data.userId == "user_xyz"
     * @deny (delete) User with UID "user_abc" cannot delete an image owned by "user_xyz".
     *   request.auth.uid == "user_abc"
     *   resource.data.userId == "user_xyz"
     * @principle Allows public reads while enforcing ownership for writes. Requires the 'Image' entity to have a 'userId' field.
     */
    match /images/{imageId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwnerByUserId(resource.data.userId);
      allow delete: if isExistingOwnerByUserId(resource.data.userId);
    }
  }

  // Helper functions
  function isSignedIn() {
    return request.auth != null;
  }

  function isOwner(userId) {
    return request.auth.uid == userId;
  }

  function isNewOwner(userId) {
    return isSignedIn() && request.auth.uid == userId && request.resource.data.id == userId;
  }

  function isExistingOwner(userId) {
    return isSignedIn() && request.auth.uid == userId && resource != null && resource.data.id == userId;
  }

  function isExistingOwnerByUserId(userId) {
    return isSignedIn() && request.auth.uid == userId && resource != null;
  }
}